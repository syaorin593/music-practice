<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>CYBER TIMELINE v19</title>
<style>
    /* --- ÂÖ®‰ΩìË®≠ÂÆö --- */
    body { 
        background-color: #050510; color: #fff; 
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
        margin: 0; overflow: hidden; user-select: none; touch-action: none; 
    }
    
    /* --- „É°„Éã„É•„ÉºÁîªÈù¢ --- */
    #menu-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
        z-index: 100; display: flex; flex-direction: column; align-items: center; padding-top: 20px;
        overflow-y: auto;
    }
    h1 { 
        color: #00f3ff; text-transform: uppercase; letter-spacing: 4px; font-style: italic;
        text-shadow: 0 0 15px #00f3ff; margin-bottom: 10px; border-bottom: 2px solid #00f3ff; 
    }

    /* „Ç®„É™„Ç¢ÂÖ±ÈÄö */
    .config-area {
        background: rgba(255, 255, 255, 0.05); border: 1px solid #555;
        padding: 10px; border-radius: 8px; width: 90%; max-width: 600px;
        margin-bottom: 15px; text-align: center;
    }
    .config-title { font-size: 12px; color: #aaa; margin-bottom: 5px; border-bottom:1px solid #444; padding-bottom:2px; font-weight:bold;}

    .flex-inputs { display: flex; justify-content: center; gap: 10px; margin: 5px 0; align-items: flex-end; flex-wrap: wrap; }
    .input-box { display: flex; flex-direction: column; align-items: flex-start; }
    .input-box label { font-size: 10px; color: #0f0; margin-bottom: 2px; }
    .input-box input, .input-box select { 
        width: 70px; background: #000; border: 1px solid #0f0; 
        color: #fff; padding: 5px; text-align: center; border-radius: 4px; height: 30px; font-size: 16px; /* iPadÁî®ÊñáÂ≠ó„Çµ„Ç§„Ç∫ */
    }
    .check-box { font-size: 14px; display:flex; align-items:center; height:30px; cursor: pointer;}
    .check-box input { width:20px; height:20px; margin-right: 5px; }

    /* Ëâ≤ÂàÜ„Åë */
    .metro-overlay label { color: #ff00ff; } .metro-overlay input { border-color: #ff00ff; color:#ff00ff; font-weight:bold; }
    .rec-setting label { color: #00f3ff; } .rec-setting input { border-color: #00f3ff; }

    /* Ë≠úÈù¢„É™„Çπ„Éà */
    #chart-list {
        width: 90%; max-width: 600px; height: 25vh; overflow-y: auto;
        background: rgba(0, 20, 40, 0.6); border: 1px solid #00f3ff; 
        box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);
        border-radius: 8px; padding: 10px; margin-bottom: 15px;
    }
    .chart-item {
        background: rgba(255, 255, 255, 0.05); color: #fff; 
        padding: 15px; margin-bottom: 8px; border-radius: 8px; /* Â§ß„Åç„Åè */
        display: flex; justify-content: space-between; align-items: center; 
        border-left: 6px solid #444; transition: 0.2s;
    }
    .chart-item:hover { background: rgba(0, 243, 255, 0.1); border-left-color: #00f3ff; }
    .chart-info { flex-grow: 1; text-align: left; cursor: pointer; }
    .chart-title { font-size: 18px; font-weight: bold; }
    .chart-sub { font-size: 12px; color: #888; }

    /* „Éú„Çø„É≥ */
    .menu-actions { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
    .main-btn {
        padding: 15px 30px; font-size: 16px; font-weight: bold; cursor: pointer;
        color: #000; border: none; border-radius: 8px; 
        text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
    }
    #create-btn { background: #00f3ff; box-shadow: 0 0 15px rgba(0,243,255,0.4); }
    #import-btn { background: #e0e0e0; color: #333; }
    #metro-btn { background: #0f0; box-shadow: 0 0 15px rgba(0,255,0,0.4); }
    .main-btn:active { transform: scale(0.95); }

    .btn-group { display: flex; gap: 10px; }
    .btn-mini { padding: 8px 12px; font-size: 12px; cursor: pointer; border: 1px solid #666; background: transparent; color: #aaa; border-radius: 4px; }
    .btn-del { border-color: #f05; color: #f05; }
    .btn-watch { border-color: #0f0; color: #0f0; }

    /* --- „Ç≤„Éº„É†ÁîªÈù¢ --- */
    #game-screen {
        position: relative; width: 100vw; height: 100vh;
        background: #050510; display: none;
        background-image: linear-gradient(rgba(0, 243, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 243, 255, 0.05) 1px, transparent 1px);
        background-size: 50px 50px;
    }

    /* „Çπ„ÉÜ„Éº„Çø„Çπ„Éê„ÉºÔºà„Éò„ÉÉ„ÉÄ„ÉºÔºâ„ÅÆÂ§ßÂûãÂåñ */
    #status-bar {
        position: absolute; top: 0; width: 100%; height: 80px; /* È´ò„ÅïÁ¢∫‰øù */
        padding: 10px 20px;
        display: flex; justify-content: space-between; align-items: center;
        background: linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.5)); 
        z-index: 200; box-sizing: border-box;
    }

    /* „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„Éú„Çø„É≥ÔºàiPadÁî®„Å´Â∑®Â§ßÂåñÔºâ */
    .nav-btn {
        padding: 10px 25px; font-size: 16px; font-weight: bold; cursor: pointer;
        border-radius: 8px; border: 2px solid #fff; color: #fff; background: rgba(255,255,255,0.1);
        min-width: 100px; text-align: center;
    }
    .nav-btn:active { background: #fff; color: #000; }
    
    #btn-stop { border-color: #ff4444; color: #ff4444; }
    #btn-retry { border-color: #00f3ff; color: #00f3ff; }

    #score-display-area { text-align: right; }
    #score-live { font-family: 'Courier New', monospace; font-size: 32px; color: #fff; text-shadow: 0 0 10px #00f3ff; font-weight: bold; line-height: 1;}
    #rank-live { font-size: 16px; color: #aaa; font-weight: bold; }

    #timeline-track {
        position: absolute; top: 55%; left: 0; width: 100%; height: 180px; /* Â∞ë„ÅóÂ§™„Åè */
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.6);
        border-top: 4px solid #00f3ff; border-bottom: 4px solid #00f3ff;
        overflow: hidden;
        box-shadow: 0 0 30px rgba(0, 243, 255, 0.1);
    }

    /* Âà§ÂÆöÊû† */
    #judge-point {
        position: absolute; top: 50%; left: 20%; 
        width: 100px; height: 100px; 
        transform: translate(-50%, -50%);
        border: 6px solid #fff; border-radius: 50%;
        background: rgba(255,255,255,0.05);
        z-index: 10;
        box-shadow: 0 0 20px rgba(255,255,255,0.5);
    }
    .hit-anim { border-color: #00f3ff !important; background: rgba(0, 243, 255, 0.3) !important; transform: translate(-50%, -50%) scale(1.1) !important; box-shadow: 0 0 40px #00f3ff !important; }
    .hold-anim { border-color: #ffaa00 !important; background: rgba(255, 170, 0, 0.2) !important; }

    /* „Éé„Éº„ÉÑ */
    .note {
        position: absolute; top: 50%; height: 100px;
        transform: translate(-50%, -50%);
        z-index: 8; pointer-events: none;
        box-sizing: border-box;
        display: flex; align-items: center; justify-content: center;
    }
    .note-tap {
        width: 100px; border-radius: 50%;
        background: #00f3ff; border: 5px solid #fff;
        box-shadow: 0 0 20px #00f3ff;
    }
    .note-tap::after {
        content: ''; position: absolute; width: 50px; height: 50px;
        border-radius: 50%; background: rgba(255,255,255,0.4);
    }
    .note-hold {
        border-radius: 50px; background: #ffaa00; border: 5px solid #fff;
        box-shadow: 0 0 20px #ffaa00; justify-content: flex-end;
    }
    .note-hold::after {
        content: ''; position: absolute; right: -5px; top: -5px;
        width: 100px; height: 100px; border-radius: 50%; border: 5px solid #fff; background: transparent;
    }

    /* Âà§ÂÆöÊñáÂ≠ó */
    #judge-text {
        position: absolute; top: 25%; left: 20%; transform: translate(-50%, -50%);
        font-size: 60px; font-weight: 900; font-style: italic;
        text-shadow: 0 0 30px rgba(0,0,0,0.8); opacity: 0; z-index: 20; letter-spacing: 2px;
    }

    /* „Ç≥„É≥„ÉúË°®Á§∫ */
    #combo-container {
        position: absolute; top: 50%; left: 20%; transform: translate(-50%, -50%);
        z-index: 5; text-align: center; pointer-events: none; opacity: 0;
        transition: transform 0.05s;
    }
    #combo-num { font-size: 50px; font-weight: bold; color: #fff; text-shadow: 0 0 15px #00f3ff; line-height: 1; }
    #combo-label { font-size: 14px; color: #00f3ff; font-weight: bold; letter-spacing: 2px; }

    /* „É™„Ç∂„É´„Éà */
    #result-screen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95); z-index: 900;
        display: none; flex-direction: column; align-items: center; justify-content: center;
    }
    .result-box {
        border: 2px solid #fff; padding: 40px; width: 85%; max-width: 500px;
        text-align: center; background: #111;
        box-shadow: 0 0 50px rgba(0, 243, 255, 0.2); border-radius: 16px;
        position: relative;
    }
    /* „É©„É≥„ÇØË°®Á§∫ */
    #final-rank { font-size: 120px; font-weight: 900; line-height: 1; margin: 10px 0; text-shadow: 0 0 30px currentColor; }
    
    .rank-s { color: #ffd700; }
    .rank-a { color: #ff4444; }
    .rank-b { color: #00f3ff; }
    .rank-c { color: #0f0; }
    .rank-d { color: #888; }

    #special-banner {
        font-size: 28px; font-weight: bold; margin-bottom: 10px;
        background: linear-gradient(90deg, transparent, #fff, transparent);
        -webkit-background-clip: text; color: transparent; 
        text-shadow: 0 0 20px rgba(255,255,255,0.5); display: none;
    }
    .fc-style { color: #ffd700 !important; text-shadow: 0 0 20px #ffd700 !important; background: none !important; }
    .ap-style { background: linear-gradient(90deg, #f00, #ff0, #0f0, #0ff, #00f, #f0f) !important; -webkit-background-clip: text !important; text-shadow: 0 0 10px rgba(255,255,255,0.8) !important; animation: rainbow 2s linear infinite; }
    @keyframes rainbow { 0%{filter: hue-rotate(0deg);} 100%{filter: hue-rotate(360deg);} }

    .res-score { font-size: 60px; font-weight: bold; color: #fff; margin: 5px 0; font-family: 'Impact', sans-serif; }
    .res-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; text-align: left; padding: 0 30px; }
    .res-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding-bottom: 2px; }
    .res-label { font-size: 16px; color: #aaa; }
    .res-val { font-size: 20px; font-weight: bold; }

    .res-btn {
        padding: 15px 40px; font-size: 18px; font-weight: bold; cursor: pointer;
        color: #000; border: none; border-radius: 50px; margin: 10px;
        text-transform: uppercase; transition: 0.2s; min-width: 150px;
    }
    .btn-retry { background: #00f3ff; }
    .btn-menu { background: #444; color: #fff; }
    .res-btn:active { transform: scale(0.95); }

    /* „É≠„Éº„Éá„Ç£„É≥„Ç∞ */
    #loading-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); z-index: 2000;
        display: none; flex-direction: column; align-items: center; justify-content: center;
    }
    .spinner {
        width: 60px; height: 60px; border: 6px solid #333; border-top: 6px solid #00f3ff;
        border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* „É¢„Éº„ÉÄ„É´ */
    .modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9); z-index: 900;
        display: none; align-items: center; justify-content: center;
    }
    .modal-content {
        background: #111; color: #fff; padding: 30px; border: 2px solid #333;
        text-align: center; width: 90%; max-width: 500px; border-radius: 16px;
    }
    textarea { width: 100%; height: 100px; background: #000; color: #0f0; border: 1px solid #333; padding: 10px; font-size: 14px;}

</style>
</head>
<body>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-msg">NOW LOADING...</div>
    </div>

    <div id="menu-screen">
        <h1>CYBER TIMELINE v19</h1>
        
        <div class="config-area">
            <div class="config-title" style="color:#0f0;">METRONOME MODE (NO FILE)</div>
            <div class="flex-inputs">
                <div class="input-box"><label>BPM</label><input type="number" id="metro-bpm" value="120" min="30" max="300"></div>
                <div class="input-box"><label>TIME(s)</label><input type="number" id="metro-dur" value="60" min="10"></div>
                <div class="input-box"><label>SOUND</label>
                    <select id="metro-sound">
                        <option value="wood">Wood</option>
                        <option value="beep">Beep</option>
                        <option value="click">Click</option>
                    </select>
                </div>
            </div>
            <button id="metro-btn" class="main-btn" onclick="startMetronome()">START METRONOME</button>
        </div>

        <div class="config-area rec-setting" style="border-color:#00f3ff;">
            <div class="config-title" style="color:#00f3ff;">REC / PLAY SETTING</div>
            <div class="flex-inputs">
                <div class="input-box"><label>START(s)</label><input type="number" id="trim-start" value="0" min="0" step="0.1"></div>
                <div class="input-box"><label>END(s)</label><input type="number" id="trim-end" value="0" min="0" step="0.1"></div>
            </div>
            <div style="margin-top:10px; border-top:1px solid #444; padding-top:5px;">
                <div style="font-size:10px; color:#ff00ff; margin-bottom:5px;">OVERLAY METRONOME</div>
                <div class="flex-inputs metro-overlay">
                    <label class="check-box"><input type="checkbox" id="overlay-enable">Active</label>
                    <div class="input-box"><label>BPM</label><input type="number" id="overlay-bpm" value="120"></div>
                    <div class="input-box"><label>OFFSET(s)</label><input type="number" id="overlay-offset" value="0.0" step="0.01"></div>
                </div>
            </div>
            <button id="create-btn" class="main-btn" onclick="startCreateNew()">NEW CHART</button>
        </div>

        <div id="chart-list"></div>

        <div class="menu-actions">
            <button id="import-btn" class="main-btn" onclick="openImportModal()">IMPORT DATA</button>
        </div>
        <button onclick="resetAllData()" style="background:none; border:none; color:#444; font-size:10px; margin-top:20px; cursor:pointer;">[RESET ALL DATA]</button>
        
        <input type="file" id="audio-input" accept=".mp3,audio/*" style="display:none">
    </div>

    <div id="game-screen">
        <div id="status-bar">
            <div style="display:flex; gap:20px;">
                <button id="btn-stop" class="nav-btn" onclick="quitGameForce()">‚ñ† MENU</button>
                <button id="btn-retry" class="nav-btn" onclick="restartGame(this)">‚Üª RETRY</button>
            </div>
            
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div id="mode-display" style="font-weight:bold; color:#00f3ff; font-size:18px;">PLAY</div>
                <button id="btn-toggle-metro" class="btn-mini" onclick="toggleOverlayMetro(this)" style="margin-top:5px; font-size:12px; width:100px; padding:5px;">METRO: OFF</button>
            </div>

            <div id="score-display-area">
                <div id="score-live">000000</div>
                <div id="rank-live">RANK --</div>
            </div>
        </div>

        <div id="timeline-track">
            <div id="judge-point"></div>
            <div id="combo-container">
                <div id="combo-num">0</div>
                <div id="combo-label">COMBO</div>
            </div>
            <div id="notes-container"></div>
        </div>

        <div id="judge-text">READY</div>
        <div style="position:absolute; bottom:30px; width:100%; text-align:center; color:rgba(255,255,255,0.3); font-size:14px; letter-spacing:2px; font-weight:bold;">
            TAP SCREEN
        </div>
    </div>

    <div id="result-screen">
        <div class="result-box">
            <h2 style="color:#fff; margin-top:0;">RESULT</h2>
            <div id="special-banner">FULL COMBO!!</div>
            <div id="final-rank" class="rank-s">S</div>
            <div class="res-score" id="res-score">1000000</div>
            
            <div class="res-grid">
                <div class="res-row"><span class="res-label">PERFECT</span><span class="res-val" style="color:#00f3ff" id="res-perf">0</span></div>
                <div class="res-row"><span class="res-label">GREAT</span><span class="res-val" style="color:#f0f" id="res-great">0</span></div>
                <div class="res-row"><span class="res-label">GOOD</span><span class="res-val" style="color:#0f0" id="res-good">0</span></div>
                <div class="res-row"><span class="res-label">MISS</span><span class="res-val" style="color:#555" id="res-miss">0</span></div>
                <div class="res-row" style="margin-top:10px;"><span class="res-label">MAX COMBO</span><span class="res-val" id="res-combo">0</span></div>
            </div>
            
            <br>
            <button class="res-btn btn-retry" onclick="restartGameFromResult()">RETRY</button>
            <button class="res-btn btn-menu" onclick="closeResultToMenu()">MENU</button>
        </div>
    </div>

    <div id="export-modal" class="modal">
        <div class="modal-content"><h3>EXPORT DATA</h3><textarea id="export-text" readonly></textarea><br><br><button class="main-btn" onclick="copyToClipboard()" style="background:#00f3ff; color:black;">COPY</button><button class="main-btn" onclick="closeModal('export-modal')" style="background:#444; color:white;">CLOSE</button></div>
    </div>
    <div id="import-modal" class="modal">
        <div class="modal-content"><h3>IMPORT DATA</h3><textarea id="import-text" placeholder='Paste code here'></textarea><br><br><button class="main-btn" onclick="executeImport()" style="background:#00f3ff; color:black;">ADD</button><button class="main-btn" onclick="closeModal('import-modal')" style="background:#444; color:white;">CLOSE</button></div>
    </div>
    <div id="edit-modal" class="modal">
        <div class="modal-content"><h3>EDIT TITLE</h3><input type="text" id="edit-title-input" style="padding:15px; width:80%; background:#000; color:#fff; border:1px solid #444; font-size:18px;"><br><br><button class="main-btn" onclick="saveEditedTitle()" style="background:#00f3ff; color:black;">SAVE</button><button class="main-btn" onclick="closeModal('edit-modal')" style="background:#444; color:white;">CANCEL</button></div>
    </div>

<script>
    // === Ë®≠ÂÆö ===
    const J_PERFECT = 0.05; // 100%
    const J_GREAT = 0.10;   // 80%
    const J_GOOD = 0.15;    // 50%
    
    const SPEED_BASE = 400; 
    const NOTE_SIZE = 100;
    const MAX_SCORE = 1000000;

    // === Â§âÊï∞ ===
    let savedCharts = [];
    let currentChart = null;
    let audioCtx, musicBuffer, musicSource, gainNode;
    let isRunning = false;
    let mode = ''; 
    let startTime = 0;
    let animationId;
    
    let recStartTime = 0;
    let isRecHolding = false;
    let activeNotes = [];
    let currentHoldNote = null;
    let lastNoteTime = 0;
    let isFadingOut = false;
    
    let stats = { perfect: 0, great: 0, good: 0, miss: 0, combo: 0, maxCombo: 0, score: 0 };
    let scorePerNote = 0;
    
    let editingId = null;
    let metroNextTime = 0;
    let isOverlayMetroEnabled = false;

    window.onload = () => {
        try {
            const json = localStorage.getItem('cyber_timeline_v19');
            if (json) savedCharts = JSON.parse(json);
        } catch (e) { console.error(e); }
        renderChartList();
    };

    function saveCharts() {
        localStorage.setItem('cyber_timeline_v19', JSON.stringify(savedCharts));
        renderChartList();
    }
    function resetAllData() { if(confirm("ÂÖ®„Éá„Éº„ÇøÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü")) { localStorage.removeItem('cyber_timeline_v19'); savedCharts = []; renderChartList(); } }

    const audioInput = document.getElementById('audio-input');
    const loadingOverlay = document.getElementById('loading-overlay');

    async function initAudioCtx() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') await audioCtx.resume();
    }
    async function loadAudio(file) {
        if(!audioCtx) await initAudioCtx();
        const buf = await file.arrayBuffer();
        musicBuffer = await audioCtx.decodeAudioData(buf);
    }

    // === „É°„Éà„É≠„Éé„Éº„É† ===
    function startMetronome() {
        initAudioCtx().then(() => {
            const bpm = parseInt(document.getElementById('metro-bpm').value) || 120;
            const dur = parseInt(document.getElementById('metro-dur').value) || 60;
            const notes = [];
            const interval = 60 / bpm;
            for(let t = 0; t < dur; t += interval) notes.push({ time: t, duration: 0, type: 'tap' });

            currentChart = {
                id: 'metro', title: `METRO BPM:${bpm}`, data: notes, 
                trimStart: 0, trimEnd: dur, isMetro: true, bpm: bpm
            };
            musicBuffer = null; metroNextTime = 0; isOverlayMetroEnabled = true;
            startGame('METRONOME');
        });
    }

    // === Èå≤Èü≥„Éª„Éó„É¨„Ç§ ===
    function startCreateNew() {
        initAudioCtx(); 
        const start = parseFloat(document.getElementById('trim-start').value) || 0;
        const end = parseFloat(document.getElementById('trim-end').value) || 0;
        const ovEnable = document.getElementById('overlay-enable').checked;
        const ovBpm = parseInt(document.getElementById('overlay-bpm').value) || 120;
        const ovOffset = parseFloat(document.getElementById('overlay-offset').value) || 0;

        audioInput.value = "";
        audioInput.onchange = async (e) => {
            const file = e.target.files[0];
            if(!file) return;
            loadingOverlay.style.display = 'flex';
            try {
                await loadAudio(file);
                currentChart = {
                    id: Date.now().toString(), title: file.name.replace(/\.[^/.]+$/, ""), data: [],
                    trimStart: start, trimEnd: end, overlayMetro: ovEnable, overlayBpm: ovBpm, overlayOffset: ovOffset
                };
                loadingOverlay.style.display = 'none';
                startGame('REC');
            } catch(err) { loadingOverlay.style.display = 'none'; alert("Error: " + err); }
        };
        audioInput.click();
    }

    function startPlay(id, playMode = 'PLAY') {
        initAudioCtx(); 
        currentChart = savedCharts.find(c => c.id === id);
        if(!currentChart) return;
        
        document.getElementById('trim-start').value = currentChart.trimStart || 0;
        document.getElementById('trim-end').value = currentChart.trimEnd || 0;
        document.getElementById('overlay-enable').checked = currentChart.overlayMetro || false;
        document.getElementById('overlay-bpm').value = currentChart.overlayBpm || 120;
        document.getElementById('overlay-offset').value = currentChart.overlayOffset || 0.0;

        const msg = playMode === 'AUTO' ? "„Éó„É¨„Éì„É•„Éº(Ëá™ÂãïÂÜçÁîü)" : "„Éó„É¨„Ç§";
        setTimeout(() => {
            if(confirm(`„Äå${currentChart.title}„Äç„Çí${msg}„Åó„Åæ„Åô„ÄÇ\nMP3„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`)) {
                audioInput.value = "";
                audioInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if(!file) return;
                    loadingOverlay.style.display = 'flex';
                    try {
                        await loadAudio(file);
                        loadingOverlay.style.display = 'none';
                        startGame(playMode);
                    } catch(err) { loadingOverlay.style.display = 'none'; alert("Error: " + err); }
                };
                audioInput.click();
            }
        }, 50);
    }

    // === „Ç≤„Éº„É†ÈñãÂßã ===
    function startGame(selectedMode) {
        mode = selectedMode;
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'block';

        const disp = document.getElementById('mode-display');
        const stopBtn = document.getElementById('btn-stop');
        
        if(mode === 'REC') { 
            disp.textContent = "‚óè REC"; disp.style.color = "#ff4444"; 
            stopBtn.textContent = "‚ñ† MENU / SAVE"; stopBtn.style.borderColor = "#f05"; stopBtn.style.color = "#f05";
        }
        else if(mode === 'AUTO') { 
            disp.textContent = "üëÅ AUTO"; disp.style.color = "#0f0"; 
            stopBtn.textContent = "‚ñ† MENU"; stopBtn.style.borderColor = "#fff"; stopBtn.style.color = "#fff";
        }
        else if(mode === 'METRONOME') { 
            disp.textContent = "‚è± METRO"; disp.style.color = "#0f0"; 
            stopBtn.textContent = "‚ñ† MENU"; stopBtn.style.borderColor = "#fff"; stopBtn.style.color = "#fff";
        }
        else { 
            disp.textContent = "‚ñ∂ PLAY"; disp.style.color = "#00f3ff"; 
            stopBtn.textContent = "‚ñ† MENU"; stopBtn.style.borderColor = "#fff"; stopBtn.style.color = "#fff";
        }

        if(currentChart.data) {
            currentChart.data.forEach(d => { delete d._spawned; });
            if(currentChart.data.length > 0) {
                const lastRel = Math.max(...currentChart.data.map(d => d.time + (d.duration || 0)));
                lastNoteTime = lastRel + 2.0;
            } else { lastNoteTime = 0; }
        }

        resetState();
        startTime = audioCtx.currentTime;
        
        if(mode === 'METRONOME') {
            document.getElementById('btn-toggle-metro').style.display = 'none';
            metroNextTime = 0;
        } else {
            // „Ç™„Éº„Éê„Éº„É¨„Ç§ÂàùÊúüÂåñ
            document.getElementById('btn-toggle-metro').style.display = 'inline-block';
            isOverlayMetroEnabled = currentChart.overlayMetro || false;
            updateMetroBtn();
            if(currentChart.overlayBpm) {
                const interval = 60.0 / currentChart.overlayBpm;
                const offset = currentChart.overlayOffset || 0;
                let nextBeat = offset;
                while(nextBeat < currentChart.trimStart) nextBeat += interval;
                metroNextTime = nextBeat - currentChart.trimStart; 
            }
            playMusic();
        }
        
        isRunning = true;
        loop();
    }

    function restartGame(btn) {
        if(btn) btn.blur(); 
        if(confirm("ÊúÄÂàù„Åã„Çâ„ÇÑ„ÇäÁõ¥„Åó„Åæ„Åô„ÅãÔºü")) {
            isRunning = false;
            cancelAnimationFrame(animationId);
            if(musicSource) { try{musicSource.stop()}catch(e){} }
            startGame(mode);
        }
    }
    
    function restartGameFromResult() { startGame(mode); }

    function resetState() {
        document.getElementById('notes-container').innerHTML = '';
        activeNotes = [];
        currentHoldNote = null;
        isRecHolding = false;
        isFadingOut = false;
        stats = { perfect: 0, great: 0, good: 0, miss: 0, combo: 0, maxCombo: 0, score: 0 };
        
        const totalNotes = currentChart.data.length || 1;
        scorePerNote = MAX_SCORE / totalNotes;
        
        updateScoreUI();
        document.getElementById('combo-container').style.opacity = 0;
    }

    function updateScoreUI() {
        document.getElementById('score-live').textContent = Math.round(stats.score).toString().padStart(7, '0');
        
        let rank = 'D';
        const percent = (stats.score / MAX_SCORE) * 100;
        if(percent >= 95) rank = 'S';
        else if(percent >= 80) rank = 'A';
        else if(percent >= 60) rank = 'B';
        else if(percent >= 40) rank = 'C';
        
        const rankEl = document.getElementById('rank-live');
        rankEl.textContent = `RANK ${rank}`;
        rankEl.className = `rank-${rank.toLowerCase()}`;
        if(stats.score === 0) rankEl.textContent = "RANK --";
    }

    // === „É´„Éº„Éó ===
    function loop() {
        if(!isRunning) return;
        const now = audioCtx.currentTime;
        const gameTime = now - startTime;
        
        // „É°„Éà„É≠„Éé„Éº„É†Èü≥
        let interval = 0; let endLimit = 99999;
        if(mode === 'METRONOME') {
            const inputBpm = parseInt(document.getElementById('metro-bpm').value) || 120;
            interval = 60.0 / inputBpm; endLimit = currentChart.trimEnd;
        } else if(currentChart.overlayMetro) {
            const bpm = currentChart.overlayBpm || 120; interval = 60.0 / bpm;
            let tEnd = currentChart.trimEnd || 0; if(tEnd===0 && musicBuffer) tEnd = musicBuffer.duration;
            endLimit = tEnd - currentChart.trimStart;
        }
        if(interval > 0) {
            while (metroNextTime < gameTime + 0.1) {
                if(metroNextTime <= endLimit) {
                    if(mode === 'METRONOME' || isOverlayMetroEnabled) playClick(startTime + metroNextTime);
                }
                metroNextTime += interval;
            }
        }

        // „Éé„Éº„ÉÑÂá¶ÁêÜ
        const pxPerSec = SPEED_BASE * 1.2; 
        const judgeX = window.innerWidth * 0.2;

        if(mode === 'METRONOME') {
            const inputBpm = parseInt(document.getElementById('metro-bpm').value) || 120;
            const mInt = 60.0 / inputBpm;
            const lookAhead = (window.innerWidth - judgeX) / pxPerSec;
            const nextIdx = Math.ceil((gameTime + lookAhead) / mInt);
            const nextTime = nextIdx * mInt;
            const nid = `m-${nextIdx}`;
            if(!document.getElementById(nid) && nextTime <= currentChart.trimEnd && nextTime < gameTime + lookAhead + 0.1) {
                createNoteElement({ time: nextTime, duration: 0, type: 'tap' }, nid);
            }
        } else if(mode !== 'REC') {
            const lookAhead = (window.innerWidth - judgeX) / pxPerSec;
            currentChart.data.forEach(d => {
                if(!d._spawned && d.time < gameTime + lookAhead + 1.5 && d.time > gameTime - 1) {
                    createNoteElement(d); d._spawned = true;
                }
            });
        }

        activeNotes.forEach((n, idx) => {
            const diff = n.data.time - gameTime;
            const x = judgeX + (diff * pxPerSec);
            let width = NOTE_SIZE;
            if(n.data.type === 'hold') width = (n.data.duration * pxPerSec) + NOTE_SIZE;

            n.el.style.left = n.data.type === 'hold' ? `${x + (width/2) - (NOTE_SIZE/2)}px` : `${x}px`;
            n.el.style.width = `${width}px`;

            if(mode === 'AUTO' || mode === 'METRONOME') {
                if(!n.processed) {
                    if(n.data.type === 'tap' && diff <= 0) triggerHit(n, 'PERFECT', mode!=='METRONOME');
                    if(n.data.type === 'hold') if(diff <= 0 && (!currentHoldNote || currentHoldNote.uid !== n.uid)) startHold(n, mode!=='METRONOME');
                }
                if(n.data.type === 'hold' && currentHoldNote && currentHoldNote.uid === n.uid) {
                    if(gameTime >= n.data.time + n.data.duration) completeHold(n, mode!=='METRONOME');
                }
            } else {
                if(!n.processed) {
                    if(n.data.type === 'tap' && diff < -J_GOOD) triggerMiss(n);
                    if(n.data.type === 'hold' && diff < -J_GOOD && (!currentHoldNote || currentHoldNote.uid !== n.uid)) triggerMiss(n);
                }
            }

            if(n.processed) {
                if(n.data.type === 'tap' && diff < -0.1) removeNote(idx);
                if(n.data.type === 'hold' && gameTime > n.data.time + n.data.duration + 0.2) removeNote(idx);
            } else if(x + width < -100) removeNote(idx);
        });

        // ÁµÇ‰∫ÜÂà§ÂÆö
        let finishTime = lastNoteTime;
        let tEnd = currentChart.trimEnd || 0;
        if(tEnd === 0 && musicBuffer) tEnd = musicBuffer.duration;
        else if(tEnd === 0 && mode === 'METRONOME') tEnd = currentChart.trimEnd;
        const songDuration = tEnd - currentChart.trimStart;

        if (mode === 'REC') {
            if (gameTime > songDuration && !isFadingOut) showResult(); 
        } else {
            let autoExitTime = 99999;
            if(currentChart.data && currentChart.data.length > 0) autoExitTime = lastNoteTime + 2.0;
            const actualEndTime = Math.min(songDuration, autoExitTime);
            if (gameTime > actualEndTime && !isFadingOut) {
                if(musicSource && gainNode) {
                    isFadingOut = true;
                    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.0);
                    setTimeout(showResult, 1200);
                } else showResult();
            }
        }

        if(musicBuffer && gameTime > musicBuffer.duration + 2 && !isFadingOut) showResult();
        else if (isRunning) animationId = requestAnimationFrame(loop);
    }

    function createNoteElement(data, idOverride=null) {
        const el = document.createElement('div');
        el.className = data.type === 'hold' ? 'note note-hold' : 'note note-tap';
        if(idOverride) el.id = idOverride;
        document.getElementById('notes-container').appendChild(el);
        activeNotes.push({ uid: Date.now()+Math.random(), data: data, el: el, processed: false });
    }
    function removeNote(idx) {
        const n = activeNotes[idx]; if(n && n.el) n.el.remove(); activeNotes.splice(idx, 1);
    }

    // === Âà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ ===
    function triggerHit(note, quality, sound=true) {
        note.processed = true; note.el.remove();
        let point = 0;
        if(quality === 'PERFECT') {
            stats.perfect++; point = 100;
            showJudge("PERFECT", "#00f3ff");
        } else if(quality === 'GREAT') {
            stats.great++; point = 80;
            showJudge("GREAT", "#f0f");
        } else {
            stats.good++; point = 50;
            showJudge("GOOD", "#0f0");
        }
        
        stats.score += scorePerNote * (point / 100);
        stats.combo++;
        if(stats.combo > stats.maxCombo) stats.maxCombo = stats.combo;
        updateComboUI(); updateScoreUI();
        if(sound) playSE(quality === 'PERFECT' ? 1000 : (quality==='GREAT' ? 800 : 600));
    }

    function triggerMiss(note) {
        note.processed = true; note.el.style.opacity = 0.3;
        stats.miss++; stats.combo = 0;
        showJudge("MISS", "#555");
        updateComboUI(); updateScoreUI();
    }

    function startHold(note, sound=true) {
        currentHoldNote = note;
        showJudge("HOLD...", "#ffaa00");
        document.getElementById('judge-point').classList.add('hold-anim');
        if(sound) playSE(600);
    }
    function completeHold(note, sound=true) {
        note.processed = true; note.el.style.opacity = 0;
        currentHoldNote = null;
        stats.perfect++; 
        stats.score += scorePerNote; 
        stats.combo++;
        if(stats.combo > stats.maxCombo) stats.maxCombo = stats.combo;
        
        document.getElementById('judge-point').classList.remove('hold-anim');
        showJudge("PERFECT", "#00f3ff");
        if(sound) playSE(1000);
        updateScoreUI(); updateComboUI();
    }

    // === ÂÖ•Âäõ ===
    const inputStart = (e) => {
        if(!isRunning || mode === 'AUTO' || mode === 'METRONOME') return;
        if(e.type === 'keydown') { if(e.code !== 'Space') return; if(e.repeat) return; }
        if(e.type === 'touchstart') e.preventDefault();

        const now = audioCtx.currentTime - startTime;
        const jp = document.getElementById('judge-point');
        jp.classList.remove('hit-anim'); void jp.offsetWidth; jp.classList.add('hit-anim');

        if(mode === 'REC') {
            if(isRecHolding) return; recStartTime = now; isRecHolding = true; playSE(600);
        } else {
            let target = null; let minDiff = 999;
            activeNotes.forEach(n => {
                if(n.processed) return;
                const diff = Math.abs(n.data.time - now);
                if(diff < J_GOOD && diff < minDiff) { minDiff = diff; target = n; }
            });

            if(target) {
                if(target.data.type === 'tap') {
                    if(minDiff <= J_PERFECT) triggerHit(target, 'PERFECT');
                    else if(minDiff <= J_GREAT) triggerHit(target, 'GREAT');
                    else triggerHit(target, 'GOOD');
                } else {
                    startHold(target);
                }
            }
        }
    };

    const inputEnd = (e) => {
        if(!isRunning || mode === 'AUTO' || mode === 'METRONOME') return;
        if(e.type === 'keyup' && e.code !== 'Space') return;
        const now = audioCtx.currentTime - startTime;

        if(mode === 'REC' && isRecHolding) {
            const duration = now - recStartTime;
            const type = duration > 0.15 ? 'hold' : 'tap';
            currentChart.data.push({ time: recStartTime, duration: type==='hold'?duration:0, type: type });
            isRecHolding = false;
            showJudge(type.toUpperCase(), "#fff");
        } 
        else if(mode === 'PLAY' && currentHoldNote) {
            const endTime = currentHoldNote.data.time + currentHoldNote.data.duration;
            const diff = Math.abs(now - endTime);
            if (diff < J_GOOD) completeHold(currentHoldNote);
            else if (now < endTime - J_GOOD) {
                triggerMiss(currentHoldNote);
                currentHoldNote = null;
                document.getElementById('judge-point').classList.remove('hold-anim');
            }
        }
    };

    window.addEventListener('keydown', inputStart);
    window.addEventListener('keyup', inputEnd);
    const gs = document.getElementById('game-screen');
    gs.addEventListener('touchstart', inputStart, {passive:false});
    gs.addEventListener('touchend', inputEnd);
    gs.addEventListener('mousedown', inputStart);
    gs.addEventListener('mouseup', inputEnd);

    // === UIÊºîÂá∫ ===
    function showJudge(text, color) {
        const el = document.getElementById('judge-text');
        el.textContent = text; el.style.color = color; el.style.opacity = 1;
        el.animate([{opacity:1, transform:"translate(-50%,-50%) scale(1.5)"}, {opacity:0, transform:"translate(-50%,-50%) scale(1.0)"}], {duration:250, fill:'forwards'});
    }
    function updateComboUI() {
        const c = document.getElementById('combo-container');
        const n = document.getElementById('combo-num');
        if(stats.combo > 1) {
            n.textContent = stats.combo;
            c.style.opacity = 1;
            c.style.transform = "translate(-50%, -50%) scale(1.2)";
            setTimeout(() => c.style.transform = "translate(-50%, -50%) scale(1.0)", 50);
        } else {
            c.style.opacity = 0;
        }
    }

    function toggleOverlayMetro(btn) {
        if(btn) btn.blur();
        isOverlayMetroEnabled = !isOverlayMetroEnabled;
        updateMetroBtn();
    }
    function updateMetroBtn() {
        const btn = document.getElementById('btn-toggle-metro');
        if(isOverlayMetroEnabled) { btn.textContent = "METRO: ON"; btn.style.color = "#0f0"; btn.style.borderColor = "#0f0"; }
        else { btn.textContent = "METRO: OFF"; btn.style.color = "#555"; btn.style.borderColor = "#555"; }
    }

    function playMusic() {
        if(musicSource) { try{musicSource.stop()}catch(e){} }
        musicSource = audioCtx.createBufferSource();
        musicSource.buffer = musicBuffer;
        gainNode = audioCtx.createGain();
        musicSource.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const tStart = currentChart.trimStart || 0;
        let tEnd = currentChart.trimEnd || 0;
        if(tEnd === 0 || tEnd > musicBuffer.duration) tEnd = musicBuffer.duration;
        musicSource.start(0, tStart, tEnd - tStart);
    }
    function playClick(time) {
        const soundType = document.getElementById('metro-sound').value;
        const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
        osc.connect(g); g.connect(audioCtx.destination);
        if(soundType === 'wood') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(800, time); osc.frequency.exponentialRampToValueAtTime(300, time+0.03);
            g.gain.setValueAtTime(0.7, time); g.gain.exponentialRampToValueAtTime(0.01, time+0.05);
        } else if(soundType === 'beep') {
            osc.type = 'square'; osc.frequency.setValueAtTime(1200, time);
            g.gain.setValueAtTime(0.1, time); g.gain.setValueAtTime(0, time+0.05);
        } else {
            osc.type = 'sine'; osc.frequency.setValueAtTime(1500, time); osc.frequency.exponentialRampToValueAtTime(100, time+0.02);
            g.gain.setValueAtTime(0.5, time); g.gain.exponentialRampToValueAtTime(0.01, time+0.02);
        }
        osc.start(time); osc.stop(time+0.05);
    }
    function playSE(f) {
        const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
        o.connect(g); g.connect(audioCtx.destination);
        o.frequency.setValueAtTime(f, audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime+0.1);
        g.gain.setValueAtTime(0.3, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1);
        o.start(); o.stop(audioCtx.currentTime+0.1);
    }

    // === „É™„Ç∂„É´„Éà ===
    function showResult() {
        isRunning = false; cancelAnimationFrame(animationId);
        document.getElementById('res-score').textContent = Math.round(stats.score);
        document.getElementById('res-perf').textContent = stats.perfect;
        document.getElementById('res-great').textContent = stats.great;
        document.getElementById('res-good').textContent = stats.good;
        document.getElementById('res-miss').textContent = stats.miss;
        document.getElementById('res-combo').textContent = stats.maxCombo;
        
        const percent = (stats.score / MAX_SCORE) * 100;
        let rank = 'D'; let color = '#888';
        if(percent >= 95) { rank = 'S'; color = '#ffd700'; }
        else if(percent >= 80) { rank = 'A'; color = '#ff4444'; }
        else if(percent >= 60) { rank = 'B'; color = '#00f3ff'; }
        else if(percent >= 40) { rank = 'C'; color = '#0f0'; }
        
        const rEl = document.getElementById('final-rank');
        rEl.textContent = rank; rEl.className = `rank-${rank.toLowerCase()}`;
        
        const banner = document.getElementById('special-banner');
        banner.style.display = 'none'; banner.className = '';
        if(stats.miss === 0) {
            banner.style.display = 'block';
            if(stats.great === 0 && stats.good === 0) {
                banner.textContent = "ALL PERFECT!!"; banner.className = 'ap-style';
            } else {
                banner.textContent = "FULL COMBO!!"; banner.className = 'fc-style';
            }
        }

        document.getElementById('result-screen').style.display = 'flex';
    }
    function closeResultToMenu() { document.getElementById('result-screen').style.display = 'none'; quitGameForce(); }
    function quitGameForce() {
        isRunning = false; if(musicSource) { try{musicSource.stop()}catch(e){} } cancelAnimationFrame(animationId);
        if(mode === 'REC') {
            currentChart.data.sort((a,b) => a.time - b.time);
            const idx = savedCharts.findIndex(c => c.id === currentChart.id);
            if(idx >= 0) savedCharts[idx] = currentChart; else savedCharts.push(currentChart);
            saveCharts();
        }
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
        renderChartList();
    }

    // === „É™„Çπ„Éà‰ªñ ===
    function renderChartList() {
        const list = document.getElementById('chart-list'); list.innerHTML = '';
        if(savedCharts.length === 0) { list.innerHTML = '<div style="padding:20px;text-align:center;color:#aaa;">NO CHARTS</div>'; return; }
        savedCharts.forEach(c => {
            const div = document.createElement('div'); div.className = 'chart-item';
            div.innerHTML = `<div class="chart-info" onclick="startPlay('${c.id}')"><div class="chart-title">${c.title}</div><div class="chart-sub">Notes: ${c.data.length}</div></div><div class="btn-group"><button class="btn-mini btn-watch" onclick="startPlay('${c.id}', 'AUTO')">WATCH</button><button class="btn-mini" onclick="openEditModal('${c.id}')">EDIT</button><button class="btn-mini" onclick="openExportModal('${c.id}')">EXP</button><button class="btn-mini btn-del" onclick="deleteChart('${c.id}')">DEL</button></div>`;
            list.appendChild(div);
        });
    }
    function deleteChart(id) { if(confirm("DELETE?")) { savedCharts = savedCharts.filter(c => c.id !== id); saveCharts(); } }
    function openEditModal(id) { editingId = id; document.getElementById('edit-title-input').value = savedCharts.find(x=>x.id===id).title; document.getElementById('edit-modal').style.display = 'flex'; }
    function saveEditedTitle() { const v = document.getElementById('edit-title-input').value; if(v) { savedCharts.find(x=>x.id===editingId).title=v; saveCharts(); } closeModal('edit-modal'); }
    function openExportModal(id) { document.getElementById('export-text').value = JSON.stringify(savedCharts.find(x => x.id === id)); document.getElementById('export-modal').style.display = 'flex'; }
    function copyToClipboard() { document.getElementById('export-text').select(); document.execCommand('copy'); alert("COPIED"); }
    function openImportModal() { document.getElementById('import-text').value = ""; document.getElementById('import-modal').style.display = 'flex'; }
    function executeImport() { try { const d = JSON.parse(document.getElementById('import-text').value); if(!d.id) throw 0; d.id = Date.now().toString(); savedCharts.push(d); saveCharts(); closeModal('import-modal'); alert("IMPORTED"); } catch(e) { alert("INVALID DATA"); } }
    function closeModal(id) { document.getElementById(id).style.display = 'none'; }
    function restartGame(btn) { if(btn) btn.blur(); if(confirm("RESTART?")) { isRunning = false; cancelAnimationFrame(animationId); if(musicSource) try{musicSource.stop()}catch(e){} startGame(mode); } }
    function restartGameFromResult() { startGame(mode); }
</script>
</body>
</html>
