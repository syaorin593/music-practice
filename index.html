<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>CYBER TIMELINE v13</title>
<style>
    /* --- ÂÖ®‰ΩìË®≠ÂÆö --- */
    body { 
        background-color: #050510; color: #fff; 
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
        margin: 0; overflow: hidden; user-select: none; touch-action: none; 
    }
    
    /* --- „É°„Éã„É•„ÉºÁîªÈù¢ --- */
    #menu-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
        z-index: 100; display: flex; flex-direction: column; align-items: center; padding-top: 20px;
        overflow-y: auto;
    }
    h1 { 
        color: #00f3ff; text-transform: uppercase; letter-spacing: 4px; font-style: italic;
        text-shadow: 0 0 15px #00f3ff; margin-bottom: 10px; border-bottom: 2px solid #00f3ff; 
    }

    /* „Ç®„É™„Ç¢ÂÖ±ÈÄö */
    .config-area {
        background: rgba(255, 255, 255, 0.05); border: 1px solid #555;
        padding: 10px; border-radius: 8px; width: 90%; max-width: 600px;
        margin-bottom: 15px; text-align: center;
    }
    .config-title { font-size: 12px; color: #aaa; margin-bottom: 5px; border-bottom:1px solid #444; padding-bottom:2px;}

    /* „É°„Éà„É≠„Éé„Éº„É†Ë®≠ÂÆö */
    .metro-inputs { display: flex; justify-content: center; gap: 10px; margin: 5px 0; align-items: flex-end; flex-wrap: wrap; }
    .input-box { display: flex; flex-direction: column; align-items: flex-start; }
    .input-box label { font-size: 10px; color: #0f0; margin-bottom: 2px; }
    .input-box input, .input-box select { 
        width: 80px; background: #000; border: 1px solid #0f0; 
        color: #fff; padding: 5px; text-align: center; border-radius: 4px; height: 30px;
    }
    .check-box { font-size: 12px; display:flex; align-items:center; height:30px; }

    /* „Éà„É™„Éü„É≥„Ç∞Ë®≠ÂÆö */
    .trim-inputs { display: flex; justify-content: center; gap: 15px; margin: 5px 0; align-items: center; }
    .trim-box { display: flex; flex-direction: column; align-items: flex-start; }
    .trim-box label { font-size: 10px; color: #00f3ff; margin-bottom: 2px; }
    .trim-box input { 
        width: 70px; background: #000; border: 1px solid #00f3ff; 
        color: #fff; padding: 5px; text-align: center; border-radius: 4px; 
    }

    /* Ë≠úÈù¢„É™„Çπ„Éà */
    #chart-list {
        width: 90%; max-width: 600px; height: 30vh; overflow-y: auto;
        background: rgba(0, 20, 40, 0.6); border: 1px solid #00f3ff; 
        box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);
        border-radius: 8px; padding: 10px; margin-bottom: 15px;
    }
    .chart-item {
        background: rgba(255, 255, 255, 0.05); color: #fff; 
        padding: 10px; margin-bottom: 5px; border-radius: 4px;
        display: flex; justify-content: space-between; align-items: center; 
        border-left: 4px solid #444; transition: 0.2s;
    }
    .chart-item:hover { background: rgba(0, 243, 255, 0.1); border-left-color: #00f3ff; }
    
    .chart-info { flex-grow: 1; text-align: left; cursor: pointer; }
    .chart-title { font-size: 16px; font-weight: bold; }
    .chart-sub { font-size: 11px; color: #888; }

    /* „Éú„Çø„É≥ */
    .menu-actions { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    .main-btn {
        padding: 10px 20px; font-size: 14px; font-weight: bold; cursor: pointer;
        color: #000; border: none; border-radius: 4px; 
        text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
    }
    #create-btn { background: #00f3ff; box-shadow: 0 0 10px rgba(0,243,255,0.4); }
    #import-btn { background: #e0e0e0; color: #333; }
    #metro-btn { background: #0f0; box-shadow: 0 0 10px rgba(0,255,0,0.4); }
    
    .main-btn:hover { transform: scale(1.05); filter: brightness(1.1); }

    .btn-group { display: flex; gap: 5px; }
    .btn-mini { padding: 4px 8px; font-size: 10px; cursor: pointer; border: 1px solid #666; background: transparent; color: #aaa; border-radius: 4px; }
    .btn-mini:hover { border-color: #fff; color: #fff; }
    .btn-del { border-color: #f05; color: #f05; }
    .btn-watch { border-color: #0f0; color: #0f0; }

    /* --- „Ç≤„Éº„É†ÁîªÈù¢ --- */
    #game-screen {
        position: relative; width: 100vw; height: 100vh;
        background: #050510; display: none;
        background-image: 
            linear-gradient(rgba(0, 243, 255, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 243, 255, 0.05) 1px, transparent 1px);
        background-size: 50px 50px;
    }

    #status-bar {
        position: absolute; top: 0; width: 100%; padding: 10px;
        display: flex; justify-content: space-between; align-items: center;
        background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); 
        z-index: 200; box-sizing: border-box; height: 50px;
    }

    #timeline-track {
        position: absolute; top: 50%; left: 0; width: 100%; height: 160px;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.6);
        border-top: 2px solid #00f3ff; border-bottom: 2px solid #00f3ff;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
    }

    /* Âà§ÂÆöÊû† */
    #judge-point {
        position: absolute; top: 50%; left: 20%; 
        width: 90px; height: 90px; 
        transform: translate(-50%, -50%);
        border: 4px solid #fff; border-radius: 50%;
        background: rgba(255,255,255,0.05);
        z-index: 10;
        box-shadow: 0 0 10px rgba(255,255,255,0.3);
    }
    .hit-anim { border-color: #00f3ff !important; background: rgba(0, 243, 255, 0.3) !important; transform: translate(-50%, -50%) scale(1.1) !important; box-shadow: 0 0 30px #00f3ff !important; }
    .hold-anim { border-color: #ffaa00 !important; background: rgba(255, 170, 0, 0.2) !important; }

    /* „Éé„Éº„ÉÑ */
    .note {
        position: absolute; top: 50%; height: 90px;
        transform: translate(-50%, -50%);
        z-index: 8; pointer-events: none;
        box-sizing: border-box;
        display: flex; align-items: center; justify-content: center;
    }
    .note-tap {
        width: 90px; border-radius: 50%;
        background: #00f3ff; border: 4px solid #fff;
        box-shadow: 0 0 15px #00f3ff;
    }
    .note-tap::after {
        content: ''; position: absolute; width: 40px; height: 40px;
        border-radius: 50%; background: rgba(255,255,255,0.4);
    }
    .note-hold {
        border-radius: 45px; background: #ffaa00; border: 4px solid #fff;
        box-shadow: 0 0 15px #ffaa00; justify-content: flex-end;
    }
    .note-hold::after {
        content: ''; position: absolute; right: -4px; top: -4px;
        width: 90px; height: 90px; border-radius: 50%; border: 4px solid #fff; background: transparent;
    }

    #judge-text {
        position: absolute; top: 25%; left: 20%; transform: translate(-50%, -50%);
        font-size: 50px; font-weight: 900; font-style: italic;
        text-shadow: 0 0 20px rgba(0,0,0,0.8); opacity: 0; z-index: 20; letter-spacing: 2px;
    }

    #score-live {
        font-family: 'Courier New', monospace; font-size: 28px; 
        color: #fff; text-shadow: 0 0 10px #00f3ff; font-weight: bold;
    }

    /* „É™„Ç∂„É´„Éà */
    #result-screen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95); z-index: 900;
        display: none; flex-direction: column; align-items: center; justify-content: center;
    }
    .result-box {
        border: 1px solid #444; padding: 40px; width: 80%; max-width: 400px;
        text-align: center; background: #111;
        box-shadow: 0 0 50px rgba(0, 243, 255, 0.2); border-radius: 8px;
    }
    .res-score { font-size: 80px; font-weight: bold; color: #00f3ff; margin: 10px 0; font-family: 'Impact', sans-serif; }
    .res-row { display: flex; justify-content: space-between; margin: 10px 0; border-bottom: 1px solid #333; color: #aaa; font-size: 14px; }
    .res-val { color: #fff; font-weight: bold; font-size: 18px; }

    /* „É¢„Éº„ÉÄ„É´ */
    .modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9); z-index: 900;
        display: none; align-items: center; justify-content: center;
    }
    .modal-content {
        background: #111; color: #fff; padding: 25px; border: 1px solid #333;
        text-align: center; width: 90%; max-width: 400px; border-radius: 8px;
    }
    textarea { width: 100%; height: 80px; background: #000; color: #0f0; border: 1px solid #333; padding: 5px; }

</style>
</head>
<body>

    <div id="menu-screen">
        <h1>CYBER TIMELINE v13</h1>
        
        <div class="config-area">
            <div class="config-title">METRONOME MODE (NO FILE)</div>
            <div class="metro-inputs">
                <div class="input-box"><label>BPM</label><input type="number" id="metro-bpm" value="120" min="30" max="300"></div>
                <div class="input-box"><label>TIME(s)</label><input type="number" id="metro-dur" value="60" min="10"></div>
                <div class="input-box"><label>SOUND</label>
                    <select id="metro-sound">
                        <option value="wood">Wood („Ç´„ÉÉ)</option>
                        <option value="beep">Beep („Éî„ÉÉ)</option>
                        <option value="click">Click („ÉÅ„ÉÉ)</option>
                    </select>
                </div>
                <div class="check-box"><input type="checkbox" id="metro-click" checked> Sound ON</div>
            </div>
            <button id="metro-btn" class="main-btn" onclick="startMetronome()">START METRONOME</button>
        </div>

        <div class="config-area" style="border-color:#00f3ff;">
            <div class="config-title" style="color:#00f3ff;">REC SETTING (FILE REQUIRED)</div>
            <div class="trim-inputs">
                <div class="trim-box"><label>START(s)</label><input type="number" id="trim-start" value="0" min="0" step="0.1"></div>
                <div class="trim-box"><label>END(s)</label><input type="number" id="trim-end" value="0" min="0" step="0.1"></div>
            </div>
            <button id="create-btn" class="main-btn" onclick="startCreateNew()">NEW CHART</button>
        </div>

        <div id="chart-list"></div>

        <div class="menu-actions">
            <button id="import-btn" class="main-btn" onclick="openImportModal()">IMPORT DATA</button>
        </div>
        
        <button onclick="resetAllData()" style="background:none; border:none; color:#444; font-size:10px; margin-top:20px; cursor:pointer;">[RESET ALL DATA]</button>
        
        <input type="file" id="audio-input" accept=".mp3,audio/*" style="display:none">
    </div>

    <div id="game-screen">
        <div id="status-bar">
            <div>
                <button class="btn-mini" onclick="quitGameForce()" style="padding:8px 15px; border-color:#555; color:#fff;">EXIT</button>
                <button class="btn-mini" onclick="restartGame(this)" style="padding:8px 15px; border-color:#00f3ff; color:#00f3ff; margin-left:10px;">RETRY</button>
            </div>
            <div id="mode-display" style="font-weight:bold; color:#00f3ff;">PLAY</div>
            <div id="score-live">000000</div>
        </div>

        <div id="timeline-track">
            <div id="judge-point"></div>
            <div id="notes-container"></div>
        </div>

        <div id="judge-text">READY</div>
        <div style="position:absolute; bottom:30px; width:100%; text-align:center; color:rgba(255,255,255,0.3); font-size:12px; letter-spacing:2px;">
            SPACE KEY / TAP SCREEN
        </div>
    </div>

    <div id="result-screen">
        <div class="result-box">
            <h2 style="color:#fff; margin-top:0;">COMPLETE</h2>
            <div class="res-score" id="res-score">0</div>
            <div class="res-row"><span>PERFECT</span><span class="res-val" style="color:#00f3ff" id="res-perf">0</span></div>
            <div class="res-row"><span>GOOD</span><span class="res-val" style="color:#0f0" id="res-good">0</span></div>
            <div class="res-row"><span>MISS</span><span class="res-val" style="color:#555" id="res-miss">0</span></div>
            <br>
            <button class="main-btn" style="background:#00f3ff; color:#000;" onclick="restartGameFromResult()">RETRY</button>
            <button class="main-btn" style="background:#444; color:#fff;" onclick="closeResultToMenu()">MENU</button>
        </div>
    </div>

    <div id="export-modal" class="modal">
        <div class="modal-content">
            <h3>EXPORT DATA</h3>
            <textarea id="export-text" readonly></textarea>
            <br><br>
            <button class="btn-mini" onclick="copyToClipboard()" style="border-color:#00f3ff; color:#00f3ff;">COPY</button>
            <button class="btn-mini" onclick="closeModal('export-modal')">CLOSE</button>
        </div>
    </div>
    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h3>IMPORT DATA</h3>
            <textarea id="import-text" placeholder='Paste code here'></textarea>
            <br><br>
            <button class="btn-mini" onclick="executeImport()" style="border-color:#00f3ff; color:#00f3ff;">ADD</button>
            <button class="btn-mini" onclick="closeModal('import-modal')">CLOSE</button>
        </div>
    </div>
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <h3>EDIT TITLE</h3>
            <input type="text" id="edit-title-input" style="padding:10px; width:80%; background:#000; color:#fff; border:1px solid #444;">
            <br><br>
            <button class="btn-mini" onclick="saveEditedTitle()" style="border-color:#00f3ff; color:#00f3ff;">SAVE</button>
            <button class="btn-mini" onclick="closeModal('edit-modal')">CANCEL</button>
        </div>
    </div>

<script>
    // === Ë®≠ÂÆö ===
    const J_PERFECT = 0.08;
    const J_GOOD = 0.18;
    const SPEED_BASE = 400; // px/sec
    const NOTE_SIZE = 90;

    // === Â§âÊï∞ ===
    let savedCharts = [];
    let currentChart = null;
    let audioCtx, musicBuffer, musicSource, gainNode;
    let isRunning = false;
    let mode = ''; // REC, PLAY, AUTO, METRONOME
    let startTime = 0;
    let animationId;
    
    // Èå≤Èü≥„Éª„Éó„É¨„Ç§Áî®
    let recStartTime = 0;
    let isRecHolding = false;
    let activeNotes = [];
    let currentHoldNote = null;
    let lastNoteTime = 0;
    let isFadingOut = false;
    let stats = { perfect: 0, good: 0, miss: 0, score: 0 };
    let editingId = null;
    
    // „É°„Éà„É≠„Éé„Éº„É†Áî®
    let metroNextTime = 0;
    let metroBpm = 120;

    window.onload = () => {
        try {
            const json = localStorage.getItem('cyber_timeline_v13');
            if (json) savedCharts = JSON.parse(json);
        } catch (e) { console.error(e); }
        renderChartList();
    };

    function saveCharts() {
        localStorage.setItem('cyber_timeline_v13', JSON.stringify(savedCharts));
        renderChartList();
    }
    
    function resetAllData() {
        if(confirm("ÂÖ®„Éá„Éº„Çø„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü")) {
            localStorage.removeItem('cyber_timeline_v13');
            savedCharts = [];
            renderChartList();
        }
    }

    const audioInput = document.getElementById('audio-input');

    async function initAudioCtx() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') await audioCtx.resume();
    }

    async function loadAudio(file) {
        await initAudioCtx();
        const buf = await file.arrayBuffer();
        musicBuffer = await audioCtx.decodeAudioData(buf);
    }

    // === „É°„Éà„É≠„Éé„Éº„É†„É¢„Éº„Éâ ===
    function startMetronome() {
        initAudioCtx().then(() => {
            const bpm = parseInt(document.getElementById('metro-bpm').value) || 120;
            const dur = parseInt(document.getElementById('metro-dur').value) || 60;
            metroBpm = bpm;
            
            // ‰ªÆÊÉ≥Ë≠úÈù¢„Çí‰ΩúÊàê
            const notes = [];
            const interval = 60 / bpm;
            for(let t = 0; t < dur; t += interval) {
                notes.push({ time: t, duration: 0, type: 'tap' });
            }

            currentChart = {
                id: 'metro', title: `METRO BPM:${bpm} (${dur}s)`,
                data: notes, trimStart: 0, trimEnd: dur,
                isMetro: true, bpm: bpm
            };
            
            musicBuffer = null;
            metroNextTime = 0; // Áõ∏ÂØæÊôÇÈñì0„Åã„Çâ„Çπ„Çø„Éº„Éà
            
            startGame('METRONOME');
        });
    }

    // === Èå≤Èü≥„Éª„Éó„É¨„Ç§ ===
    function startCreateNew() {
        const start = parseFloat(document.getElementById('trim-start').value) || 0;
        const end = parseFloat(document.getElementById('trim-end').value) || 0;

        audioInput.value = "";
        audioInput.onchange = async (e) => {
            const file = e.target.files[0];
            if(!file) return;
            await loadAudio(file);
            currentChart = {
                id: Date.now().toString(),
                title: file.name.replace(/\.[^/.]+$/, ""),
                data: [],
                trimStart: start, trimEnd: end
            };
            startGame('REC');
        };
        audioInput.click();
    }

    function startPlay(id, playMode = 'PLAY') {
        currentChart = savedCharts.find(c => c.id === id);
        if(!currentChart) return;
        
        document.getElementById('trim-start').value = currentChart.trimStart || 0;
        document.getElementById('trim-end').value = currentChart.trimEnd || 0;

        const msg = playMode === 'AUTO' ? "„Éó„É¨„Éì„É•„Éº(Ëá™ÂãïÂÜçÁîü)" : "„Éó„É¨„Ç§";

        setTimeout(() => {
            if(confirm(`„Äå${currentChart.title}„Äç„Çí${msg}„Åó„Åæ„Åô„ÄÇ\nMP3„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`)) {
                audioInput.value = "";
                audioInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if(!file) return;
                    await loadAudio(file);
                    startGame(playMode);
                };
                audioInput.click();
            }
        }, 50);
    }

    // === „Ç≤„Éº„É†ÈñãÂßã ===
    function startGame(selectedMode) {
        mode = selectedMode;
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'block';

        const disp = document.getElementById('mode-display');
        if(mode === 'REC') { disp.textContent = "‚óè REC"; disp.style.color = "#ff4444"; }
        else if(mode === 'AUTO') { disp.textContent = "üëÅ AUTO"; disp.style.color = "#0f0"; }
        else if(mode === 'METRONOME') { disp.textContent = "‚è± METRO"; disp.style.color = "#0f0"; }
        else { disp.textContent = "‚ñ∂ PLAY"; disp.style.color = "#00f3ff"; }

        // „Éï„É©„Ç∞„É™„Çª„ÉÉ„Éà
        if(currentChart.data) {
            currentChart.data.forEach(d => { delete d._spawned; });
            if(currentChart.data.length > 0) {
                const lastRel = Math.max(...currentChart.data.map(d => d.time + (d.duration || 0)));
                lastNoteTime = lastRel + 2.0;
            } else { lastNoteTime = 0; }
        }

        resetState();
        
        startTime = audioCtx.currentTime;
        
        if(mode === 'METRONOME') {
            // „É°„Éà„É≠„Éé„Éº„É†„ÅØÈü≥„ÇíÈ≥¥„Çâ„Åï„Åö„ÄÅ„É´„Éº„ÉóÂÜÖ„Åß„Çπ„Ç±„Ç∏„É•„Éº„É´„Åô„Çã
        } else {
            playMusic();
        }
        
        isRunning = true;
        loop();
    }

    function restartGame(btn) {
        if(btn) btn.blur(); 
        if(confirm("ÊúÄÂàù„Åã„Çâ„ÇÑ„ÇäÁõ¥„Åó„Åæ„Åô„ÅãÔºü")) {
            isRunning = false;
            cancelAnimationFrame(animationId);
            if(musicSource) { try{musicSource.stop()}catch(e){} }
            startGame(mode);
        }
    }
    
    function restartGameFromResult() { startGame(mode); }

    function resetState() {
        document.getElementById('notes-container').innerHTML = '';
        activeNotes = [];
        currentHoldNote = null;
        isRecHolding = false;
        isFadingOut = false;
        stats = { perfect: 0, good: 0, miss: 0, score: 0 };
        updateScoreUI();
    }

    // --- Èü≥Â£∞ÂÜçÁîüÁ≥ª ---
    function playMusic() {
        if(musicSource) { try{musicSource.stop()}catch(e){} }
        musicSource = audioCtx.createBufferSource();
        musicSource.buffer = musicBuffer;
        gainNode = audioCtx.createGain();
        musicSource.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        const tStart = currentChart.trimStart || 0;
        let tEnd = currentChart.trimEnd || 0;
        if(tEnd === 0 || tEnd > musicBuffer.duration) tEnd = musicBuffer.duration;
        const duration = tEnd - tStart;

        musicSource.start(0, tStart, duration);
    }

    function playClick(time) {
        const soundType = document.getElementById('metro-sound').value;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.connect(g); g.connect(audioCtx.destination);
        
        if(soundType === 'wood') {
            // „Ç¶„ÉÉ„Éâ„Éñ„É≠„ÉÉ„ÇØÈ¢® (Sine + Pitch Drop)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, time);
            osc.frequency.exponentialRampToValueAtTime(300, time + 0.03);
            g.gain.setValueAtTime(0.7, time);
            g.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
            osc.start(time); osc.stop(time + 0.05);
        }
        else if(soundType === 'beep') {
            // ÈõªÂ≠êÈü≥ (Square)
            osc.type = 'square';
            osc.frequency.setValueAtTime(1200, time);
            g.gain.setValueAtTime(0.1, time);
            g.gain.setValueAtTime(0, time + 0.05);
            osc.start(time); osc.stop(time + 0.05);
        }
        else {
            // „ÇØ„É™„ÉÉ„ÇØ (High Sine)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1500, time);
            osc.frequency.exponentialRampToValueAtTime(100, time + 0.02);
            g.gain.setValueAtTime(0.5, time);
            g.gain.exponentialRampToValueAtTime(0.01, time + 0.02);
            osc.start(time); osc.stop(time + 0.02);
        }
    }

    function quitGameForce() {
        isRunning = false;
        if(musicSource) { try{musicSource.stop()}catch(e){} }
        cancelAnimationFrame(animationId);
        
        if(mode === 'REC') {
            currentChart.data.sort((a,b) => a.time - b.time);
            const idx = savedCharts.findIndex(c => c.id === currentChart.id);
            if(idx >= 0) savedCharts[idx] = currentChart;
            else savedCharts.push(currentChart);
            saveCharts();
        }

        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
        renderChartList();
    }

    // === „É´„Éº„Éó ===
    function loop() {
        if(!isRunning) return;
        const now = audioCtx.currentTime;
        const gameTime = now - startTime;
        
        // --- „É°„Éà„É≠„Éé„Éº„É†Èü≥„ÅÆ„Çπ„Ç±„Ç∏„É•„Éº„É™„É≥„Ç∞ (Lookahead) ---
        if(mode === 'METRONOME' && document.getElementById('metro-click').checked) {
            // „É™„Ç¢„É´„Çø„Ç§„É†BPMÂèçÊò†
            const inputBpm = parseInt(document.getElementById('metro-bpm').value) || 120;
            const interval = 60.0 / inputBpm;
            
            // Â∞ë„ÅóÂÖà(0.1Áßí)„Åæ„Åß„Çí‰∫àÁ¥Ñ„Åô„Çã
            while (metroNextTime < gameTime + 0.1) {
                if(metroNextTime <= currentChart.trimEnd) {
                    playClick(startTime + metroNextTime);
                }
                metroNextTime += interval;
            }
        }

        // --- „Éé„Éº„ÉÑÊèèÁîª ---
        // „É°„Éà„É≠„Éé„Éº„É†„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÄÅ„Éé„Éº„ÉÑÈñìÈöî„ÇÇBPM„Å´Âêà„Çè„Åõ„Å¶ÂãïÁöÑ„Å´Â§â„Åà„Åü„ÅÑ„Åå
        // Êó¢Â≠ò„ÅÆchart.data„ÅØÂõ∫ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ
        // BPM„ÇíÂ§â„Åà„Åü„Çâ„Äå„Éé„Éº„ÉÑ„ÅÆ‰ΩçÁΩÆ„Äç„ÇÇÂÜçË®àÁÆó„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åå„ÄÅ
        // Á∞°ÊòìÁöÑ„Å´„Äåchart.dataËá™‰Ωì„Äç„ÅØ‰Ωø„Çè„Åö„ÄÅBPM„Åã„ÇâË®àÁÆó„Åó„Å¶Ë°®Á§∫„Åô„Çã„É≠„Ç∏„ÉÉ„ÇØ„Å´„Åô„Çã
        
        const pxPerSec = SPEED_BASE * 1.2; 
        const judgeX = window.innerWidth * 0.2;

        if(mode === 'METRONOME') {
            // „É°„Éà„É≠„Éé„Éº„É†„É¢„Éº„ÉâÂ∞ÇÁî®„ÅÆ„Éé„Éº„ÉÑÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
            // ÁèæÂú®„ÅÆBPM„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅÊ¨°„Å´„Åè„Çã„Éé„Éº„ÉÑ„ÇíË°®Á§∫„Åô„Çã
            // Âé≥ÂØÜ„Å™Ë≠úÈù¢„Éá„Éº„Çø„Åß„ÅØ„Å™„Åè„ÄÅ‰∏ÄÂÆöÈñìÈöî„ÅßÁÑ°Èôê„Å´ÊµÅ„Çå„Å¶„Åè„Çã„Ç§„É°„Éº„Ç∏
            
            const inputBpm = parseInt(document.getElementById('metro-bpm').value) || 120;
            const interval = 60.0 / inputBpm;
            
            // ÁîªÈù¢Âè≥Á´Ø„Åã„ÇâÂá∫Áèæ„Åï„Åõ„Çã
            const lookAheadTime = (window.innerWidth - judgeX) / pxPerSec;
            
            // Âá∫Áèæ„Åô„Åπ„Åç„Éé„Éº„ÉÑ„ÅÆÊôÇÈñì: Math.floor(gameTime / interval) * interval ...
            // Ê¨°„Å´Âá∫Áèæ„Åô„Çã„Éé„Éº„ÉÑ„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
            const nextNoteIdx = Math.ceil((gameTime + lookAheadTime) / interval);
            const nextNoteTime = nextNoteIdx * interval;
            
            // „Åæ„Å†ÁîüÊàê„Åó„Å¶„ÅÑ„Å™„ÅÑ„Å™„ÇâÁîüÊàê
            // ID„ÇíÊôÇÂàª„Éô„Éº„Çπ„Å´„Åó„Å¶ÈáçË§áÈò≤Ê≠¢
            const nid = `m-${nextNoteIdx}`;
            if(!document.getElementById(nid) && nextNoteTime <= currentChart.trimEnd) {
                // ÁîªÈù¢Âè≥Á´Ø‰ªòËøë„Å™„ÇâÁîüÊàê
                // ÁîüÊàê„Çø„Ç§„Éü„É≥„Ç∞Âà∂Âæ°: nextNoteTime „Åå (gameTime + lookAhead) ‰ªòËøë
                // Â∞ë„Åó‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„Çã
                if(nextNoteTime < gameTime + lookAheadTime + 0.1) {
                    createNoteElement({ time: nextNoteTime, duration: 0, type: 'tap' }, nid);
                }
            }
        }
        else if(mode !== 'REC') { 
            // PLAY / AUTO
            const lookAhead = (window.innerWidth - judgeX) / pxPerSec;
            currentChart.data.forEach(d => {
                if(!d._spawned && d.time < gameTime + lookAhead + 1.5 && d.time > gameTime - 1) {
                    createNoteElement(d);
                    d._spawned = true;
                }
            });
        }

        // „Éé„Éº„ÉÑÁßªÂãï„Å®ÂâäÈô§ (ÂÖ®„É¢„Éº„ÉâÂÖ±ÈÄö)
        activeNotes.forEach((n, idx) => {
            const diff = n.data.time - gameTime;
            const x = judgeX + (diff * pxPerSec);
            let width = NOTE_SIZE;
            if(n.data.type === 'hold') width = (n.data.duration * pxPerSec) + NOTE_SIZE;

            n.el.style.left = n.data.type === 'hold' ? `${x + (width/2) - (NOTE_SIZE/2)}px` : `${x}px`;
            n.el.style.width = `${width}px`;

            // Auto/MetroÂà§ÂÆö
            if(mode === 'AUTO' || mode === 'METRONOME') {
                if(!n.processed) {
                    if(n.data.type === 'tap' && diff <= 0) {
                        // „É°„Éà„É≠„Éé„Éº„É†„É¢„Éº„Éâ„Åß„ÇØ„É™„ÉÉ„ÇØÈü≥„ÅØÂà•ÁÆ°ÁêÜ„ÄÅ„Åì„Åì„ÅØË¶ã„ÅüÁõÆ„Å†„Åë
                        triggerHit(n, 'PERFECT', mode !== 'METRONOME'); 
                    }
                    // („É°„Éà„É≠„Éé„Éº„É†„É¢„Éº„Éâ„Å´Hold„ÅØ„Å™„ÅÑ)
                    if(n.data.type === 'hold') {
                        if(diff <= 0 && (!currentHoldNote || currentHoldNote.uid !== n.uid)) startHold(n, mode !== 'METRONOME');
                    }
                }
                if(n.data.type === 'hold' && currentHoldNote && currentHoldNote.uid === n.uid) {
                    const endTime = n.data.time + n.data.duration;
                    if(gameTime >= endTime) completeHold(n, mode !== 'METRONOME');
                }
            }
            // Manual
            else {
                if(!n.processed) {
                    if(n.data.type === 'tap' && diff < -J_GOOD) triggerMiss(n);
                    if(n.data.type === 'hold' && diff < -J_GOOD && (!currentHoldNote || currentHoldNote.uid !== n.uid)) triggerMiss(n);
                }
            }

            if(n.processed) {
                if(n.data.type === 'tap' && diff < -0.1) removeNote(idx);
                if(n.data.type === 'hold' && gameTime > n.data.time + n.data.duration + 0.2) removeNote(idx);
            } else if(x + width < -100) {
                removeNote(idx);
            }
        });

        // ÁµÇ‰∫ÜÂà§ÂÆö
        let finishTime = lastNoteTime;
        if(mode === 'METRONOME') finishTime = currentChart.trimEnd;
        else if(mode === 'PLAY' && currentChart.trimEnd > 0) finishTime = currentChart.trimEnd - currentChart.trimStart; 

        if((gameTime > finishTime + 2.0 && !isFadingOut)) {
            if(musicSource && gainNode) {
                isFadingOut = true;
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.0);
                setTimeout(showResult, 1200);
            } else {
                showResult();
            }
        }

        // Âº∑Âà∂ÁµÇ‰∫Ü
        if(musicBuffer && gameTime > musicBuffer.duration + 2 && !isFadingOut) showResult();
        else if (isRunning) animationId = requestAnimationFrame(loop);
    }

    function createNoteElement(data, idOverride=null) {
        const el = document.createElement('div');
        el.className = data.type === 'hold' ? 'note note-hold' : 'note note-tap';
        if(idOverride) el.id = idOverride;
        document.getElementById('notes-container').appendChild(el);
        activeNotes.push({ uid: Date.now()+Math.random(), data: data, el: el, processed: false });
    }
    function removeNote(idx) {
        const n = activeNotes[idx];
        if(n && n.el) n.el.remove();
        activeNotes.splice(idx, 1);
    }

    // === Âà§ÂÆö ===
    function triggerHit(note, quality, sound=true) {
        note.processed = true;
        note.el.remove();
        if(quality === 'PERFECT') {
            stats.perfect++;
            stats.score += 1000;
            showJudge("PERFECT", "#00f3ff");
        } else {
            stats.good++;
            stats.score += 500;
            showJudge("GOOD", "#0f0");
        }
        if(sound) playSE(quality === 'PERFECT' ? 800 : 600);
        updateScoreUI();
    }

    function triggerMiss(note) {
        note.processed = true;
        note.el.style.opacity = 0.3;
        stats.miss++;
        showJudge("MISS", "#555");
        updateScoreUI();
    }

    function startHold(note, sound=true) {
        currentHoldNote = note;
        showJudge("HOLD...", "#ffaa00");
        document.getElementById('judge-point').classList.add('hold-anim');
        if(sound) playSE(600);
    }
    function completeHold(note, sound=true) {
        note.processed = true;
        note.el.style.opacity = 0;
        currentHoldNote = null;
        stats.perfect++;
        stats.score += 1000;
        document.getElementById('judge-point').classList.remove('hold-anim');
        showJudge("PERFECT", "#00f3ff");
        if(sound) playSE(1000);
        updateScoreUI();
    }

    function updateScoreUI() {
        document.getElementById('score-live').textContent = stats.score.toString().padStart(6, '0');
    }

    // === ÂÖ•Âäõ ===
    const inputStart = (e) => {
        if(!isRunning || mode === 'AUTO' || mode === 'METRONOME') return;
        if(e.type === 'keydown') {
            if(e.code !== 'Space') return;
            if(e.repeat) return; 
        }
        if(e.type === 'touchstart') e.preventDefault();

        const now = audioCtx.currentTime - startTime;
        const jp = document.getElementById('judge-point');
        jp.classList.remove('hit-anim'); void jp.offsetWidth; jp.classList.add('hit-anim');

        if(mode === 'REC') {
            if(isRecHolding) return;
            recStartTime = now;
            isRecHolding = true;
            playSE(600);
        } else {
            let target = null;
            let minDiff = 999;
            activeNotes.forEach(n => {
                if(n.processed) return;
                const diff = Math.abs(n.data.time - now);
                if(diff < J_GOOD && diff < minDiff) { minDiff = diff; target = n; }
            });

            if(target) {
                if(target.data.type === 'tap') {
                    if(minDiff <= J_PERFECT) triggerHit(target, 'PERFECT');
                    else triggerHit(target, 'GOOD');
                } else {
                    startHold(target);
                }
            }
        }
    };

    const inputEnd = (e) => {
        if(!isRunning || mode === 'AUTO' || mode === 'METRONOME') return;
        if(e.type === 'keyup' && e.code !== 'Space') return;
        const now = audioCtx.currentTime - startTime;

        if(mode === 'REC' && isRecHolding) {
            const duration = now - recStartTime;
            const type = duration > 0.15 ? 'hold' : 'tap';
            currentChart.data.push({ time: recStartTime, duration: type==='hold'?duration:0, type: type });
            isRecHolding = false;
            showJudge(type.toUpperCase(), "#fff");
        } 
        else if(mode === 'PLAY' && currentHoldNote) {
            const endTime = currentHoldNote.data.time + currentHoldNote.data.duration;
            const diff = now - endTime; 
            if (Math.abs(diff) < J_GOOD) completeHold(currentHoldNote);
            else if (diff < -J_GOOD) {
                triggerMiss(currentHoldNote);
                currentHoldNote = null;
                document.getElementById('judge-point').classList.remove('hold-anim');
            }
        }
    };

    window.addEventListener('keydown', inputStart);
    window.addEventListener('keyup', inputEnd);
    const gs = document.getElementById('game-screen');
    gs.addEventListener('touchstart', inputStart, {passive:false});
    gs.addEventListener('touchend', inputEnd);
    gs.addEventListener('mousedown', inputStart);
    gs.addEventListener('mouseup', inputEnd);

    // === UI ===
    function showJudge(text, color) {
        const el = document.getElementById('judge-text');
        el.textContent = text;
        el.style.color = color;
        el.style.opacity = 1;
        el.animate([{opacity:1, transform:"translate(-50%,-50%) scale(1.5)"}, {opacity:0, transform:"translate(-50%,-50%) scale(1.0)"}], {duration:200, fill:'forwards'});
    }
    
    function playSE(f) {
        if(!audioCtx) return;
        const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
        o.connect(g); g.connect(audioCtx.destination);
        o.frequency.setValueAtTime(f, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime+0.1);
        g.gain.setValueAtTime(0.3, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1);
        o.start(); o.stop(audioCtx.currentTime+0.1);
    }

    function showResult() {
        isRunning = false;
        cancelAnimationFrame(animationId);
        
        let score = 0;
        const total = currentChart.data.length;
        if(total > 0) score = Math.round(((stats.perfect*100 + stats.good*50)/(total*100))*100);
        else if(mode === 'METRONOME') score = 100;
        
        document.getElementById('res-score').textContent = score;
        document.getElementById('res-perf').textContent = stats.perfect;
        document.getElementById('res-good').textContent = stats.good;
        document.getElementById('res-miss').textContent = stats.miss;
        document.getElementById('result-screen').style.display = 'flex';
    }
    
    function closeResultToMenu() {
        document.getElementById('result-screen').style.display = 'none';
        quitGameForce();
    }

    // === „É™„Çπ„Éà & Á∑®ÈõÜ ===
    function renderChartList() {
        const list = document.getElementById('chart-list');
        list.innerHTML = '';
        if(savedCharts.length === 0) { list.innerHTML = '<div style="padding:20px; text-align:center; color:#aaa;">NO CHARTS</div>'; return; }
        savedCharts.forEach(c => {
            const div = document.createElement('div');
            div.className = 'chart-item';
            div.innerHTML = `
                <div class="chart-info" onclick="startPlay('${c.id}', 'PLAY')">
                    <div class="chart-title">${c.title}</div>
                    <div class="chart-sub">Notes: ${c.data.length} (${c.trimStart||0}s - ${c.trimEnd||'End'})</div>
                </div>
                <div class="btn-group">
                    <button class="btn-mini btn-watch" onclick="startPlay('${c.id}', 'AUTO')">WATCH</button>
                    <button class="btn-mini" onclick="openEditModal('${c.id}')">EDIT</button>
                    <button class="btn-mini" onclick="openExportModal('${c.id}')">EXP</button>
                    <button class="btn-mini btn-del" onclick="deleteChart('${c.id}')">DEL</button>
                </div>
            `;
            list.appendChild(div);
        });
    }

    function openEditModal(id) {
        editingId = id;
        const c = savedCharts.find(x => x.id === id);
        document.getElementById('edit-title-input').value = c.title;
        document.getElementById('edit-modal').style.display = 'flex';
    }
    function saveEditedTitle() {
        const val = document.getElementById('edit-title-input').value;
        if(val) {
            const c = savedCharts.find(x => x.id === editingId);
            c.title = val;
            saveCharts();
        }
        closeModal('edit-modal');
    }

    function deleteChart(id) { if(confirm("DELETE?")) { savedCharts = savedCharts.filter(c => c.id !== id); saveCharts(); } }
    function openExportModal(id) { document.getElementById('export-text').value = JSON.stringify(savedCharts.find(x => x.id === id)); document.getElementById('export-modal').style.display = 'flex'; }
    function copyToClipboard() { document.getElementById('export-text').select(); document.execCommand('copy'); alert("COPIED"); }
    function openImportModal() { document.getElementById('import-text').value = ""; document.getElementById('import-modal').style.display = 'flex'; }
    function executeImport() { try { const d = JSON.parse(document.getElementById('import-text').value); if(!d.id) throw 0; d.id = Date.now().toString(); savedCharts.push(d); saveCharts(); closeModal('import-modal'); alert("IMPORTED"); } catch(e) { alert("INVALID DATA"); } }
    function closeModal(id) { document.getElementById(id).style.display = 'none'; }
</script>
</body>
</html>
